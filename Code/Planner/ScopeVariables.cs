using Sandbox.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace HTN.Planner;

/// <summary>
/// A collection of variable names and their associated values, generated by condition evaluation and passed to 
/// task execution containing the matching task variables.
/// </summary>
public class ScopeVariables
{
	private readonly Dictionary<string, object> _bindings = [];

	public ScopeVariables()
	{
	}

	public ScopeVariables Reset()
	{
		_bindings.Clear();
		return this;
	}

	public ScopeVariables CopyFrom(ScopeVariables other)
	{
		foreach ( var kvp in other._bindings )
		{
			_bindings[kvp.Key] = kvp.Value;
		}
		return this;
	}

	public T Get<T>( string variableName )
	{
		Assert.True( variableName.StartsWith('?'), "Variable name must start with '?'" );
		Assert.True( _bindings.ContainsKey( variableName ), $"Variable '{variableName}' not found in bindings." );
		Assert.True( _bindings[variableName] is T, $"Variable '{variableName}' exists but is not expected type '{typeof( T ).Name}', is actually '{_bindings[variableName].GetType().Name}'" );
		return (T)_bindings[variableName];
	}

	// todo:
	public object this[string variableName]
	{
		set => Set( variableName, value );
	}
	public void Set( string variableName, object value ) => _bindings[variableName] = value;

	public bool Has( string variableName ) => _bindings.ContainsKey( variableName );

	public IReadOnlyDictionary<string, object> Bindings => _bindings.AsReadOnly();

	// TODO: Allow setting either to the same variable scope, or same + children

	public override string ToString() => string.Join(", ", _bindings.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
}
